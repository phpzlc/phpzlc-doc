---
title: 高级查询
permalink: doc/repository
prev_page: /doc/exception
next_page: /doc/repository/principle
description_auto: 0
description: 高级查询
tags: symfony，phpzlc，查询
---

## 概述

高级查询的核心就是规则系统。

规则即查询规则，传入规则，查询系统就会根据规则自动的生成需要的查询`Sql`，返回查询结果。

这个理念，不是什么高级的想法，对于`Symfony`本身而言，其本身的查询系统，也支持这样去做，并且还有辅助的`IDE`提示。

但我还是要说，`PHPZlc`的查询系统在`Symfony`原有的查询系统上做了一次较大的革新，会给你带来的全新的体验。

可以用以下几个词来描绘其带来的变化。

1. **聪明** 
   
    `Symfony`在进行简单查询的时候十分便捷，但是如果需要连表查询和子查询或者其他的高级查询，就比较麻烦。
    
    麻烦点在于，`ORM`的查询写法需要将查询的字段和类属性绑定，这就导致学习成本和使用成本都十分的高。
    
    `PHPZlc`通过读取`Entity`定义的数据库结构，将数据库对象化。之后分析查询SQL，自动调用`Symfony`底层的绑定方法进行绑定。
   
2. **干预**

    很多人可能对干预查询结果的实际场景不太明白，这里我可以举个例子，比如实现逻辑删除，需要给原有的查询语句加上逻辑删除的判断条件。
    
    这个工作需要的主要诉求就是一种干预诉求，因为你希望可以很干脆一次性解决这个问题。 
    
    `Symfony`本身是否支持这样的干预了？可能存在。但是使用成本和学习成本都十分的高。
   
    但是这对于`PHPZlc`却很简单，由于`PHPZlc`本质上是对于`Sql`进行拼接，只需要简单的修改`Sql`的组成部分便可以完成。
   
3. **查询链路打通**

    查询链路的打通在于连表查询时，各表中定义的`Sql`资源可以被调用。
    
    这意味着你在`A`表中定义的复杂`where`，可以在任意连接`A`表的查询中使用。这就使得`SQL`真正的成为了一种编程资源。
   
4. **丰富的基础查询规则**

    `Symfony`提供了很多的查询规则，但是还不够。
    
    `PHPZlc`对于任意字段还提供`in`,`like`, `比较`,`is null`, 等等查询规则。并且支持自定义查询规则。
    
    
**看到这里，不要后退，这是个聪明的系统，很好使用，学习使用成本也很低。** [开始学习吧!!!!](/doc/repository/principle)

   
   
   
   
    

